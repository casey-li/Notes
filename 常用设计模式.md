
- [单例模式](#单例模式)
  - [加锁的懒汉式单例（线程安全）, 使用互斥锁保证线程安全。](#加锁的懒汉式单例线程安全-使用互斥锁保证线程安全)
  - [静态局部变量的懒汉单例（C++11线程安全）](#静态局部变量的懒汉单例c11线程安全)
  - [饿汉式单例（本身就线程安全）](#饿汉式单例本身就线程安全)
  - [使用 C++11 std::call\_once 实现单例（C++11线程安全）](#使用-c11-stdcall_once-实现单例c11线程安全)

# [单例模式](https://zhuanlan.zhihu.com/p/37469260)

**1\. 什么是单例模式**

单例模式(Singleton Pattern，也称为单件模式)，是使用最广泛的设计模式之一。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。

**2\.为什么需要单例模式**

两个原因：

1.  节省资源。一个类只有一个实例，不存在多份实例，节省资源。

2.  方便控制。在一些操作公共资源的场景时，避免了多个对象引起的复杂操作。

但是在实现单例模式时，需要考虑到线程安全的问题。

**3\.线程安全**

*   什么是线程安全？

在拥有共享数据的多条线程并行执行的程序中，线程安全的代码会通过同步机制保证各个线程都可以正常且正确的执行，不会出现数据污染等意外情况。

*   如何保证线程安全？

    1.  给共享的资源加把锁，保证每个资源变量每时每刻至多被一个线程占用。
    
    2.  让线程也拥有资源，不用去共享进程中的资源。如：使用threadlocal可以为每个线程维护一个私有的本地变量。

**4\.单例模式分类**

单例模式可以分为 **懒汉式** 和 **饿汉式**，两者之间的区别在于创建实例的时间不同。

*   懒汉式

系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。这种方式要考虑线程安全。

*   饿汉式

系统一运行，就初始化创建实例，当需要时，直接调用即可。**这种方式本身就线程安全，没有多线程的线程安全问题**

**5\.单例类的特点**

*   构造函数和析构函数为私有类型，目的是禁止外部构造和析构。

*   拷贝构造函数和赋值构造函数是私有类型，目的是禁止外部拷贝和赋值，确保实例的唯一性。

*   类中有一个获取实例的静态方法，可以全局访问。

**6\.单例模式实现**

普通懒汉式单例（线程不安全）

这种情况是线程不安全的，不作详细介绍。

```c++

```

## 加锁的懒汉式单例（线程安全）, 使用互斥锁保证线程安全。

- 方法1：返回普通指针

头文件：
```c++
///  加锁的懒汉式实现  //

class SingleInstance {

public:
    // 获取单实例对象
    static SingleInstance *GetInstance();

    //释放单实例，进程退出时调用
    static void deleteInstance();

private:
    // 将其构造和析构成为私有的, 禁止外部构造和析构
    SingleInstance() {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
    }
    ~SingleInstance() {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
    }

    // 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值
    SingleInstance(const SingleInstance &signal);
    const SingleInstance &operator=(const SingleInstance &signal);

private:
    // 唯一单实例对象指针
    static SingleInstance *m_SingleInstance;
    static std::mutex m_Mutex;
};
``` 

源文件：
```c++
//初始化静态成员变量
SingleInstance *SingleInstance::m_SingleInstance = nullptr;
std::mutex SingleInstance::m_Mutex;

// 注意：不能返回指针的引用，否则存在外部被修改的风险！
SingleInstance * SingleInstance::GetInstance() {

    //  这里使用了两个 if 判断语句的技术称为双检锁；好处是，只有判断指针为空的时候才加锁，
    //  避免每次调用 GetInstance的方法都加锁，锁的开销毕竟还是有点大的。
    if (m_SingleInstance == nullptr) {
        std::unique_lock<std::mutex> lock(m_Mutex); 
        if (m_SingleInstance == nullptr) {
            m_SingleInstance = new (std::nothrow) SingleInstance();
        }
    }
    return m_SingleInstance;
}

void SingleInstance::deleteInstance() {
    std::unique_lock<std::mutex> lock(m_Mutex); // 加锁
    if (m_SingleInstance) {
        delete m_SingleInstance;
        m_SingleInstance = nullptr;
    }
}
```

- 方法2：返回智能指针

```c++
#include <iostream>
#include <memory>
#include <mutex>

class Singleton {

public:

    static std::shared_ptr<Singleton> GetInstance();

    ~Singleton() {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
    }

private:

    Singleton() {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
    }
};

static std::shared_ptr<Singleton> m_SingleInstance = nullptr;
static std::mutex m_Mutex;

std::shared_ptr<Singleton> Singleton::GetInstance() {
    if (m_SingleInstance == nullptr) {
        std::unique_lock<std::mutex> lock(m_Mutex);
        if (m_SingleInstance == nullptr) {
            m_SingleInstance = std::shared_ptr<Singleton>(new Singleton());
        }
    }
    return m_SingleInstance;
}
```
    
## 静态局部变量的懒汉单例（C++11线程安全）

静态局部变量的懒汉单例模式的优点是线程安全且易于实现，但需要注意在多线程环境中，C++11 之前的标准并不保证静态局部变量的线程安全性。在 C++11 及以后的标准中，静态局部变量的初始化在多线程环境中是线程安全的

头文件：
```c++
///  内部静态变量的懒汉实现  //

class Single {

public:
    // 获取单实例对象
    static Single GetInstance();

private:
    // 禁止外部构造, 析构, 拷贝, 赋值操作
    Single();

    ~Single();

    Single(const Single &signal);

    const Single &operator=(const Single &signal);
};
```
    
源文件：
```c++
Single Single::GetInstance() {
    /**
     * 局部静态特性的方式实现单实例。
     * 静态局部变量只在当前函数内有效，其他函数无法访问。
     * 静态局部变量只在第一次被调用的时候初始化，也存储在静态存储区，生命周期从第一次被初始化起至程序结束止。
     */
    static Single signal;
    return signal;
}


Single::Single() {
    std::cout << "构造函数" << std::endl;
}

Single::~Single() {
    std::cout << "析构函数" << std::endl;
}
```

## 饿汉式单例（本身就线程安全）

头文件：
```c++
// 饿汉实现 /

class Singleton
{
public:
    // 获取单实例
    static Singleton* GetInstance();

    // 释放单实例，进程退出时调用
    static void deleteInstance();

private:
    // 将其构造和析构成为私有的, 禁止外部构造和析构
    Singleton();
    ~Singleton();

    // 将其拷贝构造和赋值构造成为私有函数, 禁止外部拷贝和赋值
    Singleton(const Singleton &signal);
    const Singleton &operator=(const Singleton &signal);

private:
    // 唯一单实例对象指针
    static Singleton *g_pSingleton;
};
```
    

源文件：
```c++
// 代码一运行就初始化创建实例 ，本身就线程安全
Singleton* Singleton::g_pSingleton = new (std::nothrow) Singleton();

Singleton* Singleton::GetInstance() {
    return g_pSingleton;
}

void Singleton::deleteInstance() {
    if (g_pSingleton) {
        delete g_pSingleton;
        g_pSingleton = nullptr;
    }
}

Singleton::Singleton() {
    std::cout << "构造函数" << std::endl;
}

Singleton::~Singleton() {
    std::cout << "析构函数" << std::endl;
}
```

## 使用 C++11 std::call\_once 实现单例（C++11线程安全）

```c++
#include <iostream>
#include <memory>
#include <mutex>

class Singleton {
public:
    static std::shared_ptr<Singleton> getSingleton();

    ~Singleton() {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
    }

private:
    Singleton() {
        std::cout << __PRETTY_FUNCTION__ << std::endl;
    }
};

static std::shared_ptr<Singleton> singleton = nullptr;
static std::once_flag singletonFlag;

std::shared_ptr<Singleton> Singleton::getSingleton() {
    std::call_once(singletonFlag, [&] {
        singleton = std::shared_ptr<Singleton>(new Singleton());
    });
    return singleton;
}
```
    
  