**C++之其余问题**

- [1、C++的多态如何实现](#1c的多态如何实现)
- [2、为什么析构函数一般写成虚函数](#2为什么析构函数一般写成虚函数)
- [3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？](#3构造函数能否声明为虚函数或者纯虚函数析构函数呢)
- [4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间](#4基类的虚函数表存放在内存的什么区虚表指针vptr的初始化时间)
- [5、模板函数和模板类的特例化](#5模板函数和模板类的特例化)
- [6、构造函数、析构函数、虚函数可否声明为内联函数](#6构造函数析构函数虚函数可否声明为内联函数)
- [7、C++模板是什么，你知道底层怎么实现的？](#7c模板是什么你知道底层怎么实现的)
- [8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？](#8构造函数为什么不能为虚函数析构函数为什么要虚函数)
- [9、析构函数的作用，如何起作用？](#9析构函数的作用如何起作用)
- [10、构造函数和析构函数可以调用虚函数吗，为什么](#10构造函数和析构函数可以调用虚函数吗为什么)
- [11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？](#11构造函数析构函数的执行顺序构造函数和拷贝构造的内部都干了啥)
- [12、虚析构函数的作用，父类的析构函数是否要设置为虚函数？](#12虚析构函数的作用父类的析构函数是否要设置为虚函数)
- [13、构造函数析构函数可否抛出异常](#13构造函数析构函数可否抛出异常)
- [14、构造函数一般不定义为虚函数的原因](#14构造函数一般不定义为虚函数的原因)
- [15、类什么时候会析构？](#15类什么时候会析构)
- [16、构造函数或者析构函数中可以调用虚函数吗](#16构造函数或者析构函数中可以调用虚函数吗)
- [17、构造函数的关键字](#17构造函数的关键字)
- [18、构造函数、拷贝构造函数和赋值操作符的区别](#18构造函数拷贝构造函数和赋值操作符的区别)
- [19、拷贝构造函数和赋值运算符重载的区别？](#19拷贝构造函数和赋值运算符重载的区别)
- [20、什么是虚拟继承](#20什么是虚拟继承)
- [21、什么情况会自动生成默认构造函数？](#21什么情况会自动生成默认构造函数)
- [22、抽象基类为什么不能创建对象？](#22抽象基类为什么不能创建对象)
- [23、模板类和模板函数的区别是什么？](#23模板类和模板函数的区别是什么)
- [24、多继承的优缺点，作为一个开发者怎么看待多继承](#24多继承的优缺点作为一个开发者怎么看待多继承)
- [25、模板和实现可不可以不写在一个文件里面？为什么？](#25模板和实现可不可以不写在一个文件里面为什么)
- [26、将字符串“hello world”从开始到打印到屏幕上的全过程?](#26将字符串hello-world从开始到打印到屏幕上的全过程)
- [27、为什么拷贝构造函数必须传引用不能传值？](#27为什么拷贝构造函数必须传引用不能传值)
- [28、静态函数能定义为虚函数吗？常函数呢？说说你的理解](#28静态函数能定义为虚函数吗常函数呢说说你的理解)
- [29、虚函数的代价是什么？](#29虚函数的代价是什么)
- [30、说一说你了解到的移动构造函数？](#30说一说你了解到的移动构造函数)
- [31、 什么情况下会合成构造函数？都说一说，你知道的都说一下](#31-什么情况下会合成构造函数都说一说你知道的都说一下)
- [32、那什么时候需要合成拷贝构造函数呢？](#32那什么时候需要合成拷贝构造函数呢)
- [33、构造函数的执行顺序是什么？](#33构造函数的执行顺序是什么)
- [34、一个类中的全部构造函数的扩展过程是什么？](#34一个类中的全部构造函数的扩展过程是什么)
- [35、哪些函数不能是虚函数？把你知道的都说一说](#35哪些函数不能是虚函数把你知道的都说一说)
- [36、什么是纯虚函数，与虚函数的区别](#36什么是纯虚函数与虚函数的区别)

## 1、C++的多态如何实现

C++的多态性，**一言以蔽之**就是：在基类的函数前加上**virtual**关键字，在派生类中重写该函数，**运行时将会根据所指对象的实际类型来调用相应的函数**，如果对象类型是派生类，就调用派生类的函数，如果对象类型是基类，就调用基类的函数。

```c++
class Base {
public:
    virtual void fun() {
        cout << " Base::func()" << endl;
    }
};

class Son1 : public Base{
public:
    virtual void fun() override {
        cout << " Son1::func()" << endl;
    }
};

class Son2 : public Base{

};

int main() {
    Son1 son1;
    Base* pb = &son1;
    pb->fun(); //  Son1::func()
    Son2 son2;
    pb = &son2;
    pb->fun(); //  Base::func()
    return 0;
}
```

**那么为什么会出现多态性，其底层的原理是什么？**

- 虚表和虚表指针在基类对象和派生类对象中的模型

虚表：虚函数表的缩写，类中含有 virtual 关键字修饰的方法时，编译器会自动生成虚表

虚表指针：在含有虚函数的类实例化对象时，**对象地址的前4 (或8) 个字节存储的指向虚表的指针**

![](http://oss.interviewguide.cn/img/202205220022619.png)

![](http://oss.interviewguide.cn/img/202205220022551.png)

- 实现多态的过程

（1）编译器在发现基类中有虚函数时，会自动为每个含有虚函数的类生成一份虚表，该表是一个一维数组，虚表里保存了虚函数的入口地址

（2）编译器会在每个对象的前四个字节中保存一个虚表指针，即 `vptr`，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针 `vptr`，从而让 `vptr` 指向正确的虚表，从而在调用虚函数时，能找到正确的函数

（3）所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。**在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表**

（4）**当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面**

这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。

---

## 2、为什么析构函数一般写成虚函数

由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针，就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。

**如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成内存泄漏**

所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数

析构函数非虚函数，只会调用父类的析构函数！！
```c++
#include <iostream>
using namespace std;

class Parent {
public:
	Parent(){
		cout << "Parent construct function"  << endl;
	};
	~Parent(){
		cout << "Parent destructor function" <<endl;
	}
};

class Son : public Parent{
public:
	Son() {
		cout << "Son construct function"  << endl;
	};
	~Son() {
		cout << "Son destructor function" <<endl;
	}
};

int main() {
	Parent* p = new Son();
	delete p;
	p = NULL;
	return 0;
}

//Parent construct function
//Son construct function
//Parent destructor function
```
将基类的析构函数声明为虚函数
```c++
#include <iostream>
using namespace std;

class Parent {
public:
    Parent() {
        cout << "Parent construct function"  << endl;
    };
    virtual ~Parent() {
        cout << "Parent destructor function" <<endl;
    }
};

class Son : public Parent {
public:
    Son() {
        cout << "Son construct function"  << endl;
    };
    ~Son() {
        cout << "Son destructor function" <<endl;
    }
};

int main() {
    Parent* p = new Son();
    delete p;
    return 0;
}
// Parent construct function
// Son construct function
// Son destructor function
// Parent destructor function
```

但存在一种特例，在 `CRTP` (Curiously Recurring Template Pattern) 模式中，不应该将析构函数声明为虚函数，理论上所有的父类函数都不应 该声明为虚函数，因为这种继承方式，不需要虚函数表

在CRTP中，派生类通过模板继承来继承父类的接口，而不是通过常规的继承机制。在这种情况下，不需要使用虚函数表来支持动态多态性 (运行时多态性),因为**派生类的函数实现是在编译时确定的**

由于CRTP模式不需要虚函数表，因此在CRTP中，通常不将父类的函数声明为虚函数。相反，派生类通过静态多态性来实现接口的动态调用，这样可以避免虚函数表带来的性能开销

```c++
template <typename Derived>
class Base {
public:
    void func() {
        // 通过静态多态性调用派生类中的实现
        static_cast<Derived*>(this)->test();
    }
};

class Son : public Base<Son> {
public:
    void test() {
        std::cout << "Son::test()" << std::endl;
    }
};

int main() {
    Son son;
    son.func(); // 输出 "Son::test()"
    return 0;
}
```

---

## 3、构造函数能否声明为虚函数或者纯虚函数，析构函数呢？

**构造函数：**

*   虚函数对应一个vtable(虚函数表)，类中存储一个vptr指向这个vtable。如果构造函数是虚函数，就需要通过vtable调用，可是对象没有初始化就没有vptr，无法找到vtable，所以构造函数不能是虚函数
*   在C++中，构造函数和析构函数的调用是按照继承层次逐级进行的，先调用基类的构造函数，然后依次调用派生类的构造函数；在析构的时候则是相反的顺序。在构造函数执行期间，对象可能处于不完全初始化的状态，其成员和虚函数表可能尚未设置，因此调用虚函数会导致不确定的行为
  
**析构函数：**

*   析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数
*   只有在基类析构函数定义为虚函数时，调用操作符delete销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据
*   **析构函数可以是纯虚函数**，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数


根据《effective C++》的条款09：绝不在构造和析构过程中调用虚函数可知，在构造函数中虽然可以调用虚函数，但是强烈建议不要这样做。因为基类的构造的过程中，虚函数不能算作是虚函数。若构造函数中调用虚函数，可能会导致不确定行为的发生.

在构造函数和析构函数中调用虚函数的问题可以通过其他设计模式和技术来解决，比如Factory模式、Builder模式等，或者使用非虚函数的“延迟绑定”技术。总结来说，构造函数和析构函数应该尽量保持简单，避免复杂的逻辑和虚函数调用，以确保对象的正确初始化和销毁过程

---

## 4、基类的虚函数表存放在内存的什么区，虚表指针vptr的初始化时间

首先整理一下虚函数表的特征：

*   虚函数表是全局共享的元素，即全局仅有一个，在编译时就构造完成
    
*   虚函数表类似一个数组，类对象中存储vptr指针，指向虚函数表，即虚函数表不是函数，不是程序代码，不可能存储在代码段
    
*   虚函数表存储虚函数的地址, 即虚函数表的元素是指向类成员函数的指针, 而类中虚函数的个数在编译时期可以确定，即虚函数表的大小可以确定, 所以大小是在编译时期确定的，不必动态分配内存空间存储虚函数表，所以不在堆中

由于虚表指针vptr跟虚函数密不可分，对于有虚函数或者继承于拥有虚函数的基类，对该类进行实例化时，**在构造函数执行时会对虚表指针进行初始化，并且存在对象内存布局的最前面**

c++ 内存模型一般分为五个区域：栈区、堆区、全局数据区、常量区、代码区

C++中**虚函数表 vtable 位于只读数据段（.rodata），也就是C++内存模型中的常量区；而虚函数则位于代码段（.text），也就是C++内存模型中的代码区。**

---

## 5、模板函数和模板类的特例化

**引入原因**

编写单一的模板，它能适应多种类型的需求，使每种类型都具有相同的功能，但对于某种特定类型，如果要实现其特有的功能，单一模板就无法做到，这时就需要模板特例化

**定义**

对单一模板提供的一个特殊实例，它将一个或多个模板参数绑定到特定的类型或值上

**（1）模板函数特例化**

必须为原函数模板的每个模板参数都提供实参，且使用关键字template后跟一个空尖括号对<>，表明将原模板的所有模板参数提供实参

```c++
template<typename T> //模板函数
int compare(const T &v1,const T &v2) {
    if(v1 > v2) return -1;
    if(v2 > v1) return 1;
    return 0;
}

//模板特例化,满足针对字符串特定的比较，要提供所有实参，这里只有一个T
template<> 
int compare(const char* const &v1,const char* const &v2) {
    return strcmp(p1,p2);
}
``` 

**本质**

**特例化的本质是实例化一个模板，而非重载它。特例化不影响参数匹配**。参数匹配都以最佳匹配为原则。例如，此处如果是 `compare(3,5)`，则调用普通的模板，若为 `compare(“hi”,”haha”)` 则调用**特例化版本**（因为这个 `cosnt char *` 相对于 T，更匹配实参类型），注意二者函数体的语句不一样了，实现不同功能

**注意**

**模板及其特例化版本应该声明在同一个头文件中**，且所有同名模板的声明应该放在前面，后面放特例化版本

**（2）类模板特例化**

**在类中，我们可以对模板进行特例化，也可以对类进行部分特例化**。对类进行特例化时，仍然用 `template<>` 表示是一个特例化版本

```c++
//里面所有T都换成特例化类型版本sales_data
//按照最佳匹配原则，若 T != sales_data，就用普通类模板，否则，就使用含有特定功能的特例化版本。
template<>
class hash<sales_data> {
	size_t operator()(sales_data& s);
};
```

**类模板的部分特例化**

不必为所有模板参数提供实参，可以**指定一部分而非所有模板参数，一个类模板的部分特例化本身仍是一个模板**，使用它时还必须为其特例化版本中未指定的模板参数提供实参 (特例化时类名一定要和原来的模板相同，只是参数类型不同，按最佳匹配原则，哪个最匹配，就用相应的模板)

**可以特例化类中的部分成员或者特例化类中的部分成员函数而不是整个类**

```c++
template<typename T>
class Foo {
    void Bar();
    void Barst(T a)();
};

//进行int类型的特例化处理
template<>
void Foo<int>::Bar() {
    cout << "我是int型特例化" << endl;
}

Foo<string> fs;
Foo<int> fi;    // 使用特例化
fs.Bar();   // 使用的是普通模板，即Foo<string>::Bar()
fi.Bar();   // 特例化版本，执行Foo<int>::Bar()
```

---

## 6、构造函数、析构函数、虚函数可否声明为内联函数

首先，将这些函数声明为内联函数，在语法上没有错误。因为 inline 同 register 一样，只是个建议，编译器并不一定真正的内联。

> register 关键字：这个关键字请求编译器尽可能的将变量存在CPU内部寄存器中，而不是通过内存寻址访问，以提高效率

```c++
class A {
public:
    inline A() {
        cout << "inline construct()" <<endl;
    }
    inline ~A() {
        cout << "inline destruct()" <<endl;
    }
    inline virtual void  virtualFun() {
        cout << "inline virtual function" <<endl;
    }
};
    
int main() {
    A a;
    a.virtualFun();
    return 0;
}
//inline construct()
//inline virtual function
//inline destruct()
```

**构造函数和析构函数声明为内联函数是没有意义的**

《Effective C++》中所阐述的是：**将构造函数和析构函数声明为inline是没有什么意义的，即编译器并不真正对声明为inline的构造和析构函数进行内联操作，因为编译器会在构造和析构函数中添加额外的操作（申请/释放内存，构造/析构对象等），致使构造函数/析构函数并不像看上去的那么精简**。其次，**class中的函数默认是 inline 型的，编译器也只是有选择性的 inline**，将构造函数和析构函数声明为内联函数是没有什么意义的

**将虚函数声明为inline，要分情况讨论**

有的人认为虚函数被声明为inline，但是编译器并没有对其内联，他们给出的理由是inline是编译期间决定的，而虚函数是运行期决定的，即在不知道将要调用哪个函数的情况下，如何将函数内联呢？

上述观点看似正确，其实不然，如果虚函数在编译期间就能够决定将要调用哪个函数时，就能够内联，那么什么情况下编译器可以确定要调用哪个函数呢，答案是当**用对象调用虚函数**（此时不具有多态性）时，就内联展开

**综上**，当是指向派生类的指针（多态性）调用声明为inline的虚函数时，不会内联展开；当是对象本身调用虚函数时，会内联展开，当然前提依然是函数并不复杂的情况下

---

## 7、C++模板是什么，你知道底层怎么实现的？

1.  编译器并不是把函数模板处理成能够处理任意类型的函数；编译器从函数模板通过具体类型产生不同的函数。**编译器会对函数模板进行两次编译：在声明的地方对模板代码本身进行编译，在调用的地方对参数替换后的代码进行编译**
    
2.  这是因为函数模板要被实例化后才能成为真正的函数，在使用函数模板的源文件中包含函数模板的头文件，如果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误
    
---

## 8、构造函数为什么不能为虚函数？析构函数为什么要虚函数？

1、 从存储空间角度，虚函数相应一个指向 vtable 虚函数表的指针，这大家都知道，但是这个指向vtable 的指针事实上是存储在对象的内存空间的

问题出来了，假设构造函数是虚的，就须要通过 vptr 来调用，但是对象还没有实例化，也就是内存空间还没有，怎么找vtable呢？所以构造函数不能是虚函数

**虚函数的作用在于通过父类的指针或者引用来调用它的时候可以变成调用子类的那个成员函数。而构造函数是在创建对象时自己主动调用的，不可能通过父类的指针或者引用去调用，因此也就规定构造函数不能是虚函数**

2、从实现上看，vtable 在构造函数调用后才建立，因而构造函数不可能成为虚函数。从实际含义上看，在调用构造函数时还不能确定对象的真实类型（由于子类会调父类的构造函数）；并且**构造函数的作用是提供初始化，在对象生命期仅仅运行一次，不是对象的动态行为，也没有必要成为虚函数**

**4、当一个构造函数被调用时，它做的首要的事情之中的一个是初始化它的 vptr**

因此，它仅仅能知道它是“当前”类的，而全然忽视这个对象后面是否还有继承者。当编译器为这个构造函数产生代码时，它是为这个类的构造函数产生代码——既不是为基类，也不是为它的派生类（由于类不知道谁继承它）。所以它使用的 vptr 必须是对于这个类的 vtable

构造函数本来就是为了明确初始化对象成员才产生的，然而virtual function主要是为了再不完全了解细节的情况下也能正确处理对象。另外，virtual函数是在不同类型的对象产生不同的动作，现在对象还没有产生，如何使用virtual函数来完成你想完成的动作

- C++中基类采用虚析构函数是**为了防止内存泄漏。**

具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。

---

## 9、析构函数的作用，如何起作用？

析构函数是C++类中的特殊成员函数，用于在对象生命周期结束时进行清理工作。它的作用是释放对象所占用的资源，比如释放动态分配的内存、关闭文件、释放打开的资源等 (避免资源泄漏)

析构函数的命名规则为在类名前面加上一个波浪号（~），后面紧跟类名，表示它是该类的析构函数。**它没有返回值，也不接受任何参数，而且不能重载，在一个类中只能有一个析构函数**

当对象被销毁时，编译器会自动调用对象的析构函数。在以下情况下，对象的析构函数会被调用：

1. 当对象的作用域结束时（比如对象在函数内部被定义，在函数结束时对象的作用域结束）

2. 当对象是动态分配（使用new运算符）的，在调用delete运算符释放对象时，析构函数会被调用

3. 当对象是静态变量，程序结束时会自动调用析构函数。

4. 对象是成员对象，并且包含它的类的析构函数被调用时，成员对象的析构函数也会被调用。

每一个类必须有一个析构函数，用户可以自定义析构函数，也可以是编译器自动生成默认的析构函数。一般析构函数定义为类的公有成员。析构函数调用顺序与构造函数调用顺序相反

---

## 10、构造函数和析构函数可以调用虚函数吗，为什么

1.  在C++中，提倡不在构造函数和析构函数中调用虚函数；
    
2.  构造函数和析构函数调用虚函数时都不使用动态联编，如果在构造函数或析构函数中调用虚函数，则运行的是为构造函数或析构函数自身类型定义的版本；
    
3.  **因为父类对象会在子类之前进行构造，此时子类部分的数据成员还未初始化，因此调用子类的虚函数是不安全的，故而C++不会进行动态联编**；
    
4.  析构函数是用来销毁一个对象的，在销毁一个对象时，**先调用子类的析构函数，然后再调用基类的析构函数。所以在调用基类的析构函数时，派生类对象的数据成员已经销毁，这个时候再调用子类的虚函数没有任何意义**

---

## 11、构造函数、析构函数的执行顺序？构造函数和拷贝构造的内部都干了啥？

- 1) 构造函数顺序

① 基类构造函数。如果有多个基类，则构造函数的调用顺序是基类在类派生表中出现的顺序，而不是它们在成员初始化表中的顺序。

② 成员类对象构造函数。如果有多个成员类对象则构造函数的调用顺序是**对象在类中被声明的顺序**，而不是它们出现在成员初始化表中的顺序

③ 派生类构造函数


- 2) 析构函数顺序

① 调用派生类的析构函数；

② 调用成员类对象的析构函数；

③ 调用基类的析构函数。

```c++
#include <iostream>

class Base {
public:
    Base() {
        std::cout << "Base constructor" << std::endl;
    }
};

class Member1 {
public:
    Member1() {
        std::cout << "Member1 constructor" << std::endl;
    }
};

class Member2 {
public:
    Member2() {
        std::cout << "Member2 constructor" << std::endl;
    }
};

// Base, Member2, Member1, Derived
class Derived : public Base {
public:
    Member2 member2;
    Member1 member1;

    Derived() {
        std::cout << "Derived constructor" << std::endl;
    }
};

int main() {
    Derived d;
    return 0;
}

// Base constructor   
// Member2 constructor
// Member1 constructor
// Derived constructor
// Derived destructor
// Member1 destructor
// Member2 destructor
// Base destructor
```

---

## 12、虚析构函数的作用，父类的析构函数是否要设置为虚函数？

1.  C++中基类采用虚析构函数是为了**防止内存泄漏**

具体地说，如果派生类中申请了内存空间，并在其析构函数中对这些内存空间进行释放。

假设基类中采用的是非虚析构函数，当删除基类指针指向的派生类对象时就不会触发动态绑定，因而只会调用基类的析构函数，而不会调用派生类的析构函数。

那么在这种情况下，派生类中申请的空间就得不到释放从而产生内存泄漏。

所以，为了防止这种情况的发生，C++中基类的析构函数应采用virtual虚析构函数。

2.  **纯虚析构函数一定得定义**，因为每一个派生类析构函数会被编译器加以扩张，以静态调用的方式调用其每一个虚基类以及上一层基类的析构函数。

因此，缺乏任何一个基类析构函数的定义，就会导致链接失败，**最好不要把虚析构函数定义为纯虚析构函数**

---

## 13、构造函数析构函数可否抛出异常

1. 构造函数中抛出异常：如果在对象的构造函数中发生异常，那么对象的析构函数不会被调用。因为**C++只会析构已经完成的对象**，而对象只有在其构造函数执行完毕才算是完全构造。因此在构造函数中发生异常会导致资源泄漏。在构造函数中应该避免抛出异常，或者在构造函数中使用资源管理技术来确保在发生异常时能够正确地释放资源。

2. 析构函数中抛出异常：如果在析构函数中抛出异常，并且这个异常没有被局部捕获（也就是说异常没有在析构函数中被处理），那么程序会调用std::terminate函数来终止程序的执行。这是因为在析构函数中抛出异常会导致析构函数无法完成对象的正确清理工作，这样会破坏程序的一致性，因此C++标准库选择默认终止程序的执行。

3. 使用智能指针（如std::unique_ptr和std::shared_ptr）来管理资源，它们能更好地处理资源的所有权和异常情况，避免资源泄漏，并且具有更好的语义。

---

## 14、构造函数一般不定义为虚函数的原因

（1）创建一个对象时需要确定对象的类型，而虚函数是在运行时动态确定其类型的。在构造一个对象时，由于对象还未创建成功，编译器无法知道对象的实际类型

（2）虚函数的调用需要虚函数表指针vptr，而该指针存放在对象的内存空间中，若构造函数声明为虚函数，那么由于对象还未创建，还没有内存空间，更没有虚函数表vtable地址用来调用虚构造函数了

（3）虚函数的作用在于通过父类的指针或者引用调用它的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类或者引用去调用，因此就规定构造函数不能是虚函数

---

## 15、类什么时候会析构？

1.  对象生命周期结束，被销毁时；
    
2.  delete指向对象的指针时，或delete指向对象的基类类型指针，而其基类虚构函数是虚函数时；
    
3.  对象i是对象o的成员，o的析构函数被调用时，对象i的析构函数也被调用。

---

## 16、构造函数或者析构函数中可以调用虚函数吗

*   从语法上讲，调用完全没有问题。
*   但是从效果上看，往往不能达到需要的目的。

> 《Effective C++》的解释是： 派生类对象构造期间进入基类的构造函数时，对象类型变成了基类类型，而不是派生类类型。 同样，进入基类析构函数时，对象也是基类类型

```c++
class Base {
public:
    Base() {
        Function();
    }

    virtual void Function() {
        cout << "Base::Fuction" << endl;
    }

    ~Base() {
        Function();
    }
};

class A : public Base {
public:
    A() {
        Function();
    }

    virtual void Function() {
        cout << "A::Function" << endl;
    }

    ~A() {
        Function();
    }
};

int main() {
    Base* a = new Base;
    delete a;
    cout << "-------------------------" <<endl;
    Base* b = new A;//语句1
    delete b;
}

//输出结果
//Base::Fuction
//Base::Fuction
//-------------------------
//Base::Fuction
//A::Function
//Base::Fuction
```

语句1讲道理应该体现多态性，执行类A中的构造和析构函数，从实验结果来看，语句1并没有体现，执行流程是先构造基类，所以先调用基类的构造函数，构造完成再执行A自己的构造函数，析构时也是调用基类的析构函数，也就是说构造和析构中调用虚函数并不能达到目的，应该避免

---

## 17、构造函数的关键字

- default: default 关键字可以显式要求编译器生成合成构造函数，防止在调用时相关构造函数类型没有定义而报错

- delete: delete 关键字可以删除构造函数、赋值运算符函数等

虚函数还有 = 0 这个关键字，能将虚函数定义为纯虚函数（纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，函数体可以定义在类的外部也可以定义在内部

---

## 18、构造函数、拷贝构造函数和赋值操作符的区别

**构造函数**

对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数

**拷贝构造函数**

对象不存在，但是使用别的已经存在的对象来进行初始化

**赋值运算符**

对象存在，用别的对象给它赋值，这属于重载 “=” 号运算符的范畴，“=” 号两侧的对象都是已存在的

```c++
class A {
public:
    A() {
        cout << "我是构造函数" << endl;
    }
    A(const A &a) {
        cout << "我是拷贝构造函数" << endl;
    }
    A &operator=(A &a) {
        cout << "我是赋值操作符" << endl;
        return *this;
    }
    ~A(){};
};

int main() {
    A a1;      // 调用构造函数
    A a2 = a1; // 调用拷贝构造函数
    a2 = a1;   // 调用赋值操作符
    return 0;
}
```

---

## 19、拷贝构造函数和赋值运算符重载的区别？

*   拷贝构造函数是函数，赋值运算符是运算符重载。
    
*   拷贝构造函数会生成新的类对象，赋值运算符不能。
    
*   **拷贝构造函数是直接构造一个新的类对象，所以在初始化对象前不需要检查源对象和新建对象是否相同；赋值运算符需要上述操作并提供两套不同的复制策略，另外赋值运算符中如果原来的对象有内存分配则需要先把内存释放掉**
    
*   形参传递是调用拷贝构造函数（调用的被赋值对象的拷贝构造函数），但并不是所有出现"="的地方都是使用赋值运算符，如下：

```c++
Student s;
Student s1 = s;    // 调用拷贝构造函数
Student s2;
s2 = s;    // 赋值运算符操作
```

**注：类中有指针变量时要重写析构函数、拷贝构造函数和赋值运算符**

---

## 20、什么是虚拟继承

由于C++支持多继承，除了public、protected 和 private 三种继承方式外，还支持虚拟（virtual）继承

虚拟继承会引入一个虚基类指针（bptr），用于在继承链中追踪虚基类

```c++
class A {};
class B : virtual public A {};
class C : virtual public A {};
class D : public B, public C {};

int main() {
    cout << "sizeof(A): " << sizeof(A) <<endl; // 1，空对象，只有一个占位
    cout << "sizeof(B): " << sizeof(B) <<endl; // 8，一个 bptr 指针，省去占位, 不需要对齐
    cout << "sizeof(C): " << sizeof(C) <<endl; // 8，一个 bptr 指针，省去占位, 不需要对齐
    cout << "sizeof(D): " << sizeof(D) <<endl; // 16，两个 bptr，省去占位, 不需要对齐
}
```

上述代码所体现的关系是，B 和 C 虚拟继承 A，D 又公有继承 B 和 C，这种方式是一种**菱形继承或者钻石继承**，可以用如下图来表示

![](http://oss.interviewguide.cn/img/202205220025114.png)

![](http://oss.interviewguide.cn/img/202205220022397.png)

虚拟继承是C++中用来解决菱形继承（diamond inheritance）问题的一种机制。在菱形继承中，由于多条继承路径共同继承同一个基类，可能导致派生类中存在多个基类子对象，这就造成了二义性问题

虚拟继承解决了这个问题，它确保在继承链中，共同的基类只有一个实体，这样就消除了二义性。在虚拟继承中，派生类会增加一个虚基类指针（bptr）, 指向虚基类子对象，或者指向一个相关的表格，表格中存放的不是虚基类子对象的地址，就是其偏移量

在一些编译器中，如果在虚拟继承的情况下同时存在vptr和bptr，一些优化可能会将它们合并为一个指针，以减少额外的内存开销。这样的优化可以减少虚拟继承所带来的额外负担，并提高程序的性能

```c++
// 若有虚函数，最终覆盖者必须重写该虚函数
class A {
public:
    virtual void func() { cout << "A::func()" << endl; }
};

class B : virtual public A {
public:
    void func() override { cout << "B::func()" << endl; }
};

class C : virtual public A {
public:
    void func() override { cout << "C::func()" << endl; }
};

class D : public B, public C {
public:
    // 若不重写的话，编译错误 (error: no unique final overrider for 'virtual void A::func()' in 'D')
    void func() override { cout << "D::func()" << endl; }
};

int main() {
    D d;
    d.func();   // D::func()
    d.::A::func(); // A::func()
    d.::B::func(); // B::func()
    d.::C::func(); // C::func()
    return 0;
}

// 若为一般成员函数，且多个基类都重写了同一个函数的话，最终的基类也必须重写，否则会报错不明确
// 但若只有 B 重写了 func() 而 C 没有重写的话就没关系, 即使 D 没重写 func(), d.func() 调用的是 B::func()
class A {
public:
    void func() { cout << "A::func()" << endl; }
};

class B : virtual public A {
public:
    void func() { cout << "B::func()" << endl; }
};

class C : virtual public A {
public:
    void func() { cout << "C::func()" << endl; }
};

class D : public B, public C {
public:
    // 若不重写的话，编译错误 (error: request for member 'func' is ambiguous)
    void func() { cout << "D::func()" << endl; }
};

int main() {
    D d;
    d.func();   // D::func()
    d.::A::func(); // A::func()
    d.::B::func(); // B::func()
    d.::C::func(); // C::func()
    return 0;
}
```
---

## 21、什么情况会自动生成默认构造函数？

- **带有默认构造函数的类成员对象**

如果一个类没有任何构造函数，但它含有一个成员对象，而该成员对象有默认构造函数，那么编译器会为该类合成一个默认构造函数。这个合成的默认构造函数会调用成员对象的默认构造函数来初始化成员对象。

如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；

- **带有默认构造函数的基类：**

如果一个没有任何构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；
    
- **带有虚函数的类**

如果一个类具有虚函数（即在类中声明了虚函数），即使没有显示定义构造函数，编译器也会合成一个默认构造函数。这样做是为了确保在创建派生类对象时，能够正确初始化虚函数表和虚函数相关的数据

- **带有虚基类的类**

如果一个类派生自一个带有虚基类的基类，并且派生类没有显示定义构造函数，编译器会合成一个默认构造函数。这个合成的构造函数会调用虚基类的默认构造函数，确保虚基类部分正确初始化
    
注意：**编译器自动生成的默认构造函数只负责初始化基类和成员类对象**。对于其他非静态数据成员，它们不会被初始化，因此它们的值是未定义的。如果需要对其他非静态数据成员进行初始化，可以通过自定义构造函数来实现

---

## 22、抽象基类为什么不能创建对象？

抽象基类不能创建对象的主要原因是它包含纯虚函数。抽象基类是一种特殊的类，它用于定义接口并为派生类提供一组通用的函数声明，但是在抽象基类中并没有为这些函数提供具体的实现。

**由于抽象基类中包含纯虚函数，它的实例化对象没有意义，因为它并没有提供完整的实现。因此，编译器不允许创建抽象基类的对象**

1、抽象类的定义：称带有纯虚函数的类为抽象类。

2、抽象类的作用：抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。

3、 抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。抽象类是不能定义对象的。一个纯虚函数不需要（但是可以）被定义。

4、纯虚函数定义 纯虚函数是一种特殊的虚函数，它的一般格式如下：

> class <类名> { virtual <类型><函数名>(<参数表>) = 0; }; 

**在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用** 　

纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。**凡是含有纯虚函数的类叫做抽象类。这种类不能声明对象，只是作为基类为派生类服务。除非在派生类中完全实现基类中所有的的纯虚函数，否则，派生类也变成了抽象类，不能实例化对象**

5、纯虚函数引入原因 
- 为了方便使用多态特性，我们常常需要在基类中定义纯虚函数
- 在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔 雀等子类，但动物本身生成对象明显不合常理

为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：`virtual ReturnType Function()= 0;`）。若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。同时含有纯虚函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题

例如，绘画程序中，shape 作为一个基类可以派生出圆形、矩形、正方形、梯形等， 如果我要求面积总和的话，那么会可以使用一个 shape * 的数组，只要依次调用派生类的 area() 函数了。如果不用接口就没法定义成数组，因为既可以是circle ,也可以是square ,而且以后还可能加上rectangle，等等

6、相似概念 

**多态性**

指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。
C++支持两种多态性：编译时多态性，运行时多态性。 　
- 编译时多态性：通过重载函数实现 　
- 运行时多态性：通过虚函数实现

**虚函数**: 虚函数是在基类中被声明为virtual，并在派生类中重新定义的成员函数，可实现成员函数的动态重载。 

**抽象类**: 　包含纯虚函数的类称为抽象类。由于抽象类包含了没有定义的纯虚函数，所以不能定义抽象类的对象

---

## 23、模板类和模板函数的区别是什么？

模板类用于创建通用类，通过参数化的方式处理不同的数据类型，而模板函数用于创建通用函数，通过参数化的方式处理不同的数据类型

类模板的实例化必须由程序员在程序中显式地指定。在使用类模板时，需要通过指定模板参数的类型来创建特定的类实例

函数模板的实例化是由编译器在处理函数调用时自动完成的。当程序中调用一个函数模板时，编译器会根据函数调用的实际参数类型推导出函数模板的模板参数类型，并自动实例化一个特定的函数版本，使其适用于具体的参数类型

**函数模板允许隐式调用和显式调用而类模板只能显示调用，在使用时类模板必须加`<T>`**

---

## 24、多继承的优缺点，作为一个开发者怎么看待多继承

1.  C++允许为一个派生类指定多个基类，这样的继承结构被称做多重继承。
    
2.  多重继承的优点很明显，就是对象可以调用多个基类中的接口；
    
3.  如果派生类所继承的多个基类有相同的基类，而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性
    
4.  加上全局符确定调用哪一份拷贝。比如 `pa.Author::eat()` 调用属于Author的拷贝。
    
5.  使用虚拟继承，使得多重继承类 Programmer_Author 只拥有Person类的一份拷贝。

---

## 25、模板和实现可不可以不写在一个文件里面？为什么？

声明与定义不写在一个文件中会导致链接错误

因为函数模板要被实例化后才能成为真正的函数，果该头文件中只有声明，没有定义，那编译器无法实例化该模板，最终导致链接错误（类模板同样！！）

编译能通过

- 参与编译的只是.cpp文件，不会报错的原因，是因为它能在.h里面找到模板的声明

链接错误。

- 链接的时候，需要实例化模板，这时候就需要找模板的具体实现了。假设在main函数中调用了一个模板函数，这时候就需要去实例化该类型的模板。注意main函数里面只包含了.h文件，也就是只有模板的声明，没有具体实现。就会报错。
- 而模板的实现.cpp里面，虽然有模板的具体实现，但是没有谁在该.cpp里面使用一个模板函数，就不会生成一个具体化的实例

在编译时模板并不能生成真正的二进制代码，而是在编译调用模板类或函数的CPP文件时才会去找对应的模板声明和实现，在这种情况下编译器是不知道实现模板类或函数的CPP文件的存在，所以它只能找到模板类或函数的声明而找不到实现，而只好创建一个符号寄希望于链接程序找地址。但模板类或函数的实现并不能被编译成二进制代码，结果链接程序找不到地址只好报错了

《C++编程思想》第15章(第300页)说明了原因：模板定义很特殊。由 template<…> 处理的任何东西都意味着编译器在当时不为它分配存储空间，它一直处于等待状态直到被一个模板实例告知。在编译器和连接器的某一处，有一机制能去掉指定模板的多重定义。所以为了容易使用，几乎总是在头文件中放置全部的模板声明和定义

```c++
// test.h, 函数模板的声明
template <typename T>
T add(T a, T b);
____________________________
// test.cpp
#include "test.h"

template <typename T>
T add(T a, T b) {
    return a + b;
}

// // 具体实例化模板
// template int add<int>(int a, int b);
____________________________
//main.cpp
#include"test.h"
 
int main() {
    int result1 = add(3, 5); #1
    return 0;
}

编译器在 #1 处并不知道 add<int> 的定义，因为它不在 test.h 里面，于是编译器只好寄希望于连接器，希望它能够在其他 .obj 里面找到 add<int> 的实例

在本例中就是 test.obj，然而，后者中真有 add<int> 的二进制代码吗？NO！！！因为C++标准明确表示，当一个模板不被用到的时侯它就不该被实例化出来，test.cpp 中用到了 add<int> 了吗？没有！！

所以实际上 test.cpp 编译出来的 test.obj 文件中关于 add<T> 函数一行二进制代码也没有。于是连接器就傻眼了，只好给出一个连接错误
```

但是，如果在 test.cpp 中具体实例化模板，则编译器就能编译，于是，`test.obj` 的符号导出表中就有了 `add<int>` 这个符号的地址，于是连接器就能够完成任务。

但是这样需要实例化 `add<int>, add<double>, add<string>,...`, 意义不大

---

## 26、将字符串“hello world”从开始到打印到屏幕上的全过程?

1.用户告诉操作系统执行HelloWorld程序（通过键盘输入等）

2．操作系统：找到helloworld程序的相关信息，检查其类型是否是可执行文件；并通过程序首部信息，确定代码和数据在可执行文件中的位置并计算出对应的磁盘块地址。

3．操作系统：创建一个新进程，将HelloWorld可执行文件映射到该进程结构，表示由该进程执行helloworld程序。

4．操作系统：为helloworld程序设置cpu上下文环境，并跳到程序开始处。

5．执行helloworld程序的第一条指令，发生缺页异常

6．操作系统：分配一页物理内存，并将代码从磁盘读入内存，然后继续执行helloworld程序

7．helloword程序执行puts函数（系统调用），在显示器上写一字符串

8．操作系统：找到要将字符串送往的显示设备，通常设备是由一个进程控制的，所以，操作系统将要写的字符串送给该进程

9．操作系统：控制设备的进程告诉设备的窗口系统，它要显示该字符串，窗口系统确定这是一个合法的操作，然后将字符串转换成像素，将像素写入设备的存储映像区

10．视频硬件将像素转换成显示器可接收和一组控制数据信号

11．显示器解释信号，激发液晶屏

12．OK，我们在屏幕上看到了HelloWorld

---

## 27、为什么拷贝构造函数必须传引用不能传值？

1.  拷贝构造函数的作用就是用来复制对象的，在使用这个对象的实例来初始化这个对象的一个新的实例。
2.  参数传递过程到底发生了什么？ 将地址传递和值传递统一起来，归根结底还是传递的是"值"(地址也是值，只不过通过它可以找到另一个值)！ 

a 值传递: 对于内置数据类型的传递时，直接赋值拷贝给形参(注意形参是函数内局部变量)； 对于类类型的传递时，需要首先调用该类的拷贝构造函数来初始化形参(局部对象)

b 引用传递: 无论对内置类型还是类类型，传递引用或指针最终都是传递的地址值！而地址总是指针类型(属于简单类型), 显然参数传递时，按简单类型的赋值拷贝，而不会有拷贝构造函数的调用(对于类类型)

**最最重要的原因是若拷贝构造函数传值的话，首先应该调用拷贝构造函数生成形参，所以拷贝构造函数使用值传递会产生无限递归调用，内存溢出**

---

## 28、静态函数能定义为虚函数吗？常函数呢？说说你的理解

**虚函数的调用关系：this -> vptr -> vtable -> virtual function**

虚函数依靠 vptr 和 vtable 来处理。vptr 是一个指针，在类的构造函数中创建生成，并且只能用 this 指针来访问它，因为它是类的一个成员，并且 vptr 指向保存虚函数地址的 vtable，所以若没有 this 指针就无法访问 vptr

静态函数是类的成员函数，但它不属于任何类对象或类实例，所以即使给此函数加上 virutal 也是没有任何意义的，并且静态函数没有 this 指针。虚函数的实现依赖于 this 指针和虚函数表（vtable）来实现动态绑定，从而在运行时确定调用哪个版本的虚函数。由于静态函数没有 this 指针，它无法访问虚函数表，因此不能定义为虚函数。

常函数可以定义为虚函数。常函数在函数签名的末尾加上 const 关键字，表示该函数不会修改类对象的成员变量。常函数在类的对象上是可以调用的，并且通过this指针可以访问虚函数表，从而实现动态绑定，因此常函数可以定义为虚函数。

---

## 29、虚函数的代价是什么？

1. 虚函数表（vtable）：为了实现动态绑定，编译器会在类的对象中添加一个指向虚函数表的指针，称为虚函数指针（vptr）。虚函数表是一个存储虚函数地址的表格，每个类只有一个虚函数表，其中包含该类及其所有基类的虚函数地址。这意味着每个对象都需要额外的内存空间来存储虚函数指针，从而增加了对象的内存消耗。

2. 虚函数的查找开销：当调用虚函数时，需要通过虚函数表来查找实际要调用的函数地址，这会带来额外的查找开销。相比于静态绑定，动态绑定的虚函数调用需要更多的指令来定位函数地址。

3. 编译器优化限制：使用虚函数会限制编译器的优化能力，因为编译器无法在编译时确定实际调用的函数，而需要在运行时动态确定。所以不能再是内联的函数，因为内联函数在编译阶段进行替代，而虚函数表示等待，在运行阶段才能确定到低是采用哪种函数，虚函数不能是内联函数

虽然虚函数带来了一些额外的开销和限制，但它提供了多态性的支持，使得程序可以在运行时根据对象的实际类型调用正确的函数，从而实现面向对象的多态特性。在需要使用多态性的情况下，虚函数是非常有价值的特性。对于需要高性能的场景，可以在关键的代码段中避免使用虚函数，或者使用虚函数的代替方法（如函数指针、模板等）来优化性能

---

## 30、说一说你了解到的移动构造函数？

1.  有时候我们会遇到这样一种情况，我们用对象 a 初始化对象 b 后对象 a 我们就不在使用了，但是对象 a 的空间还在呀（在析构之前）。既然拷贝构造函数，实际上就是把a对象的内容复制一份到b中，那么为什么我们不能直接使用a的空间呢？这样就避免了新的空间的分配，大大降低了构造的成本。这就是移动构造函数设计的初衷；
    
2.  **拷贝构造函数中，对于指针，我们一定要采用深层复制，而移动构造函数中，对于指针，我们采用浅层复制**
    
3.  C++引入了移动构造函数，专门处理这种，用a初始化b后，就将a析构的情况；
    
4.  与拷贝类似，移动也使用一个对象的值设置另一个对象的值。但是，又与拷贝不同的是，移动实现的是对象值真实的转移（源对象到目的对象）：源对象将丢失其内容，其内容将被目的对象占有。移动操作的发生的时候，是当移动值的对象是未命名的对象的时候。这里未命名的对象就是那些临时变量，甚至都不会有名称。典型的未命名对象就是函数的返回值或者类型转换的对象。**使用临时对象的值初始化另一个对象值，不会要求对对象的复制：因为临时对象不会有其它使用，因而，它的值可以被移动到目的对象**。做到这些，就要使用移动构造函数和移动赋值：当使用一个临时变量对象进行构造初始化的时候，调用移动构造函数。类似的，使用未命名的变量的值赋给一个对象时，调用移动赋值操作；

```c++
A (A &&x) : ptr(x.ptr) {
    x.ptr = nullptr;
}

// move assignment
A& operator= (A &&x) {
    delete ptr; 
    ptr = x.ptr;
    x.ptr = nullptr;
    return *this;
}
```

---

## 31、 什么情况下会合成构造函数？都说一说，你知道的都说一下

- **带有默认构造函数的类成员对象**

如果一个类没有任何构造函数，但它含有一个成员对象，而该成员对象有默认构造函数，那么编译器会为该类合成一个默认构造函数。这个合成的默认构造函数会调用成员对象的默认构造函数来初始化成员对象。

如果一个类A含有多个成员类对象的话，那么类A的每一个构造函数必须调用每一个成员对象的默认构造函数而且必须按照类对象在类A中的声明顺序进行；

- **带有默认构造函数的基类：**

如果一个没有任何构造函数的派生类派生自一个带有默认构造函数基类，那么该派生类会合成一个构造函数调用上一层基类的默认构造函数；
    
- **带有虚函数的类**

如果一个类具有虚函数（即在类中声明了虚函数），即使没有显示定义构造函数，编译器也会合成一个默认构造函数。这样做是为了确保在创建派生类对象时，能够正确初始化虚函数表和虚函数相关的数据

- **带有虚基类的类**

如果一个类派生自一个带有虚基类的基类，并且派生类没有显示定义构造函数，编译器会合成一个默认构造函数。这个合成的构造函数会调用虚基类的默认构造函数，确保虚基类部分正确初始化


还有一点需要注意的是：

1.  并不是任何没有构造函数的类都会合成一个构造函数
    
2.  编译器合成出来的构造函数并不会显示设定类内的每一个成员变量

**编译器自动生成的默认构造函数只负责初始化基类和成员类对象**。对于其他非静态数据成员，它们不会被初始化，因此它们的值是未定义的。如果需要对其他非静态数据成员进行初始化，可以通过自定义构造函数来实现

---

## 32、那什么时候需要合成拷贝构造函数呢？

1.**显示的初始化**操作：当通过使用一个对象的内容来初始化另一个对象时，会触发编译器合成拷贝构造函数。例如：`X xx = x;`

2.对象作为**参数传递**给函数：当一个类对象作为参数传递给函数时，编译器会在函数调用过程中生成临时对象，需要用到拷贝构造函数。例如：`void func(X obj);`

3.**函数返回类对象**：当函数返回一个类对象时，编译器会生成一个临时对象并用拷贝构造函数初始化。例如：`X func();`

4.类含有**成员变量**或**继承自含有拷贝构造函数的基类**：如果一个类没有定义自己的拷贝构造函数，但是它包含了一个类类型的成员变量，而该成员变量具有拷贝构造函数，或者该类继承自含有拷贝构造函数的基类，那么编译器会合成拷贝构造函数。

5.类声明或继承了**虚函数**：如果一个类声明了虚函数或继承了虚函数，编译器会为该类合成拷贝构造函数，以保证虚函数表的正确处理。

6.类含有**虚基类**：如果一个类含有虚基类，编译器会为该类合成拷贝构造函数，以正确处理虚基类的复制。
    
---

## 33、构造函数的执行顺序是什么？

1.  在派生类构造函数中，首先执行所有虚基类的构造函数，再执行所有基类的构造函数(按照声明顺序)
    
2.  对象的vptr被初始化；(After invocation of the base class constructors but before execution of user-provided code or the expansion of members initialized within the member initialization list; 在所有基类构造函数之后，但又在自身构造函数或初始化列表之前)
   
3.  依照在类中的声明顺序依次初始化成员变量, 若成员初始化列表中有则按照初始化列表中的方法初始化, 否则调用默认构造函数
   
4.  执行程序员所提供的代码；

```C++
// P1, P2 普通继承
class P1 {
public:
    P1() { cout << "父类 P1 构造函数被调用:" << endl; }
};

class P2 {
public:
    P2() { cout << "父类 P2 构造函数被调用:" << endl; }
};

// VP1, vP2 虚继承
class VP1 {
public:
    VP1() { cout << "父类 VP1 构造函数被调用:" << endl; }
};

class VP2 {
public:
    VP2() { cout << "父类 VP2 构造函数被调用:" << endl; }
};

// M1, M2 为成员变量
class M1 {
public:
    M1() { cout << "成员 M1 构造函数被调用:" << endl; }
    M1(int val): val(val) { cout << "成员 M1 有参构造函数被调用:" << endl; }
    int val;
};

class M2 {
public:
    M2() { cout << "成员 M2 构造函数被调用:" << endl; }
};

// 都倒着声明
class Son : public P2, public P1, virtual public VP2, virtual public VP1
{
public:
    Son() : m1(M1(1)) { cout << "子类 Son 构造函数被调用" << endl; }
    M2 m2;
    M1 m1;
};

int main() {
    P1 *ptr = new Son();
    delete ptr;
    return(0);
}

// 父类 VP2 构造函数被调用
// 父类 VP1 构造函数被调用
// 父类 P2 构造函数被调用
// 父类 P1 构造函数被调用
// 成员 M2 构造函数被调用
// 成员 M1 有参构造函数被调用
// 子类 Son 构造函数被调用
```

![](https://img-blog.csdnimg.cn/20201026155737840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ1ODMzMTc=,size_16,color_FFFFFF,t_70#pic_center)

对象在创建时，由编译器对vptr指针进行初始化。只有在对象的构造完全结束时，vptr指针的指向才最终确定。所以在构造函数中调用虚函数无意义

所以这也是为什么构造函数不能为虚函数。因为在创建对象时会调用构造函数，构造函数在这时初始化对象的虚表指针。如果构造函数是虚函数，那么意味着对象必须要通过虚表指针去调用构造函数，但是在调用构造函数之前，虚表指针还没被赋值，这就出现了矛盾

---

## 34、一个类中的全部构造函数的扩展过程是什么？

1.  记录在成员初始化列表中的数据成员初始化操作会被放在构造函数的函数体内，并与成员的声明顺序为顺序；
    
2.  如果一个成员并没有出现在成员初始化列表中，但它有一个默认构造函数，那么默认构造函数必须被调用；
    
3.  如果class有虚表，那么它必须被设定初值；
    
4.  所有上一层的基类构造函数必须被调用；
    
5.  所有虚基类的构造函数必须被调用。

---

## 35、哪些函数不能是虚函数？把你知道的都说一说

1.  构造函数，构造函数初始化对象，派生类必须知道基类函数干了什么，才能进行构造；当有虚函数时，每一个类有一个虚表，每一个对象有一个虚表指针，虚表指针在构造函数中初始化；
    
2.  内联函数，内联函数表示在编译阶段进行函数体的替换操作，而虚函数意味着在运行期间进行类型确定，所以内联函数不能是虚函数；
    
3.  静态函数，静态函数不属于对象属于类，静态成员函数没有this指针，因此静态函数设置为虚函数没有任何意义。
    
4.  友元函数，友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数的说法。
    
5.  普通函数，普通函数不属于类的成员函数，不具有继承特性，因此普通函数没有虚函数。
    
---

## 36、什么是纯虚函数，与虚函数的区别

**虚函数和纯虚函数区别**？

*   虚函数是为了实现动态编联产生的，目的是通过基类类型的指针指向不同对象时，自动调用相应的、和基类同名的函数（使用同一种调用形式，既能调用派生类又能调用基类的同名函数）。虚函数需要在基类中加上virtual修饰符修饰，因为virtual会被隐式继承，所以子类中相同函数都是虚函数。当一个成员函数被声明为虚函数之后，其派生类中同名函数自动成为虚函数，在派生类中重新定义此函数时要求函数名、返回值类型、参数个数和类型全部与基类函数相同。
    
*   纯虚函数只是相当于一个接口名，但含有纯虚函数的类不能够实例化。
    

纯虚函数首先是虚函数，其次它没有函数体，取而代之的是用“=0”。

既然是虚函数，它的函数指针会被存在虚函数表中，由于纯虚函数并没有具体的函数体，因此它在虚函数表中的值就为0，而具有函数体的虚函数则是函数的具体地址。

一个类中如果有纯虚函数的话，称其为抽象类。抽象类不能用于实例化对象，否则会报错。抽象类一般用于定义一些公有的方法。子类继承抽象类也必须实现其中的纯虚函数才能实例化对象。

```c++
#include <iostream>
using namespace std;

class Base {
public:
    virtual void fun1() {
        cout << "普通虚函数" << endl;
    }
    virtual void fun2() = 0;
    virtual ~Base() {}
};

class Son : public Base {
public:
    virtual void fun2() {
        cout << "子类实现的纯虚函数" << endl;
    }
};

int main() {
    Base* b = new Son;
    b->fun1(); //普通虚函数
    b->fun2(); //子类实现的纯虚函数
    return 0;
}
```

    