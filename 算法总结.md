
- [:wink: DP](#wink-dp)
  - [:lollipop: 数位 DP](#lollipop-数位-dp)
- [:wink: 并查集](#wink-并查集)
- [:wink:](#wink)
  - [:lollipop: ](#lollipop-)
- [:wink: 其他](#wink-其他)
  - [:lollipop: **运算符优先级:**](#lollipop-运算符优先级)
  - [:lollipop: **二叉树 vs 网格图 vs 一般图:**](#lollipop-二叉树-vs-网格图-vs-一般图)




# :wink: DP

## :lollipop: 数位 DP

- 记忆化仅记忆不受限制且为数字的结果

- 遍历的数字的上界由 isLimit 决定
  
  - isLimit 为 true 的话上界为当前数字
    
  - isLimit 为 false 的话上界任取，可以为 9 

- 遍历的数字的下界由 isNum 决定

  - isNum 为 true, 下界为 0

  -  isNum 为 false, 可以直接跳过计算结果 (跳过的话 isLimit 就为 false), 再计算不跳过的结果, 此时下界为 1 (跳过相当于为 0 )

- 往下递归的时候参数的改变

- mask 加上当前选的即可, 即 mask = mask | (1 << d)

- isLimit 跟当前的 isLimit 和选的数相关, isLimit = isLimit && d == up (当且仅当目前受限并且选的仍为最大值时仍受限)

-  isNum 只要选了数字就为 true, 只有为 false 时并且直接跳过时才接着为 false

`i` 和 `isLimit` 应该是必定需要的, 第二个参数根据题意选择 (要求不重复就可以传 mask, 要求统计数目就可以 cnt), 第四个参数则根据题意确定要不要 (看前导0 是否会对答案产生影响), 板子：

```c++
function<int(int, int, bool, bool)> dfs = [&](int i, int mask, bool isLimit, bool isNum) -> int {
   if (i == m) return isNum; // 到达末尾并且为数字, 返回 1
   // 去掉另外两个参数的影响
   if (!isLimit && isNum && cache[i][mask] != -1) return cache[i][mask];
   int res = 0;
   if (!isNum) { // 当前不是数字的话可以跳过, 跳过后就不受 n 的约束了
       res = dfs(i + 1, mask, false, false);
   }
   int up = isLimit ? s[i] - '0' : 9; // 确定数字上界
   // 下界跟 isNum 相关, 若是数字从 0 开始，否则从 1 开始
   for (int d = 1 - isNum; d <= up; ++d) {
       if ((mask >> d & 1) == 0) { // 当前数字没选过
           res += dfs(i + 1, mask | (1 << d), isLimit && d == up, true);
       }
   }
   if (!isLimit && isNum) { // 只记忆化不受制约并且是数字的结果
       cache[i][mask] = res;
   }
   return res;
};
```

- [2376. 统计特殊整数](https://leetcode.cn/problems/count-special-integers/description/)

纯板子, 四个参数, 用 mask, 考虑前导 0; `dfs(int i, int mask, bool isLimit, bool isNum);`

- [233. 数字 1 的个数](https://leetcode.cn/problems/number-of-digit-one/description/)
- [面试题 17.06. 2出现的次数](https://leetcode.cn/problems/number-of-2s-in-range-lcci/description/)

三个参数, 第二个参数传词频即可, 无需考虑前导 0; `dfs(int i, int cnt, bool isLimit);`

- [600. 不含连续1的非负整数](https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/description/) 

三个参数, 第二个参数传上一个选的是 0 还是 1，无需考虑前导 0; `dfs(int i, int last, bool isLimit);`

- [902. 最大为 N 的数字组合](https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/description/)

三个参数, 没有第二个参数, 需要考虑前导 0; `dfs(int i, bool isLimit, bool isNum);`

- [1012. 至少有 1 位重复的数字](https://leetcode.cn/problems/numbers-with-repeated-digits/description/)

逆向思维，求无重复数字的数目，即[2376. 统计特殊整数](https://leetcode.cn/problems/count-special-integers/description/); 也可以新增一个参数表示是否已经有重复数字了，不过空间复杂度都会加倍


# :wink: 并查集


并查集加入路径压缩和按秩合并这两个优化后, 最差情况下的时间复杂度和平均时间复杂度均为 `O(α(n))`, 其中 `α` 为阿克曼函数的反函数，其增长极其缓慢，也就是说其单次操作的平均运行时间可以认为是一个很小的常数

连通数目这一项可要可不要, 在处理二维网格这种情况时需要将坐标进行转化, `[i, j]` 转为一维即为 `i * n + j`, 板子：

```c++
// 包括两种优化：路径压缩（find函数）以及 按秩合并（sz数组）
class UnionFind {
public:
    vector<int> fa;
    vector<int> sz;
    int n;
    int comp_cnt;
    
    UnionFind(int n): n(n), comp_cnt(n), fa(n), sz(n, 1) {
        iota(fa.begin(), fa.end(), 0);
    }
    
    int find(int x) { 
        return fa[x] == x ? x : fa[x] = find(fa[x]);
    }
    
    // 把小集合中的元素并入到大集合中
    void unite(int x, int y) {
        x = find(x);
        y = find(y);
        if (x == y) return; // 这句不能忘了
        if (sz[x] < sz[y]) swap(x, y); // x 为数量更多的集合
        fa[y] = x; 
        sz[x] += sz[y];
        --comp_cnt;
    }
    
    bool is_connect(int x, int y) { return find(x) == find(y);}
};
```

- [547. 省份数量](https://leetcode.cn/problems/number-of-provinces/description/)

常规并查集

- [785. 判断二分图](https://leetcode.cn/problems/is-graph-bipartite/description/)

将与当前节点相连的所有节点合并到一个集合中，若相邻节点属于同一个集合的话则不是二分图

- [695. 岛屿的最大面积](https://leetcode.cn/problems/max-area-of-island/)

并查集写有点麻烦了, 不过可以用, 需要将二维转一维，`[i, j] -> i * n + j`
每个节点仅往下往右找 1 来避免重复计算, 当前节点为 1 的话, 判断右方和下方是否为 1, 是的话合并; 最后统计每个连通分量的大小

- [1697. 检查边长度限制的路径是否存在](https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/description/)

按最大限制对queries中的边长进行排序，同理对所有边也进行排序。在当前限制的条件下，利用并查集合并所有点，然后检查询问中的起点以及终点是否属于同一个集合即可

- [399. 除法求值](https://leetcode.cn/problems/evaluate-division/)

带权并查集, 权值为当前节点 `x` 与父亲 `f[x]` 的比值。假设两点 x 和 y 有共同的父亲f，且 `v[x] / v[f] = a, v[y] / v[f] = b`, 则 `v[x] / v[y] = a / b`

# :wink: 

## :lollipop: []()

- :cherry_blossom: 思路


- **:beers: 代码**

> c++

```c++

```

> Go

```go

```

# :wink: 其他

## :lollipop: **运算符优先级:**

`(), [], ->` 最高
`!, *` (解引用), `&` (取地址), `+`, `-` (正负号), `++, --` 次之
`*, /, %`
`+, -`
`<<, >>` (移位运算符)
`<, <=, >, >=` (比较运算符)
`==, !=`
`&` (按位与)
`^`
`|`
`&&` (逻辑与)
`||`
`=, +=, -=, ...`

## :lollipop: **二叉树 vs 网格图 vs 一般图:**

| | 重复访问 | 邻居个数 | DFS | BFS |
|---|---|---|---|---|
|二叉树|否|`≤3`|前中后序|层序|
|网格图|是|`≤4`|连通块|最短路|
|一般图|是|任意|连通块、判环等|最短路等|

> 注 1：「重复访问」指代码中是否需要处理访问过的节点。对于网格图和一般图，需要标记访问过的节点。例如在网格图中，向下访问后就不能再向上访问了，如果不做任何处理，那么会反复向下向上，无限递归下去。
> 
> 注 2：通常网格图是四方向的，每个格子的邻居个数不超过 444。如果是八方向的，则每个格子的邻居个数不超过 888。
> 
> 注 3：BFS 也可以判断连通块，但要手动用**队列**保存待访问节点；而 DFS 是计算机帮你创建了一个**栈**，自动保存递归路径上的节点，不需要手动处理。所以代码上 DFS 通常比 BFS 要简短。
